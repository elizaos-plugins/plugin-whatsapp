{"version":3,"sources":["../src/index.ts","../src/clients/baileys-client.ts","../src/baileys/auth.ts","../src/baileys/connection.ts","../src/baileys/qr-code.ts","../src/baileys/message-adapter.ts","../src/clients/cloud-api-client.ts","../src/utils/config-detector.ts","../src/clients/factory.ts","../src/handlers/message.handler.ts","../src/handlers/webhook.handler.ts","../src/service.ts"],"sourcesContent":["import { EventEmitter } from 'events';\r\nimport type { Plugin } from \"@elizaos/core\";\r\nimport type { IWhatsAppClient } from \"./clients/interface\";\r\nimport { ClientFactory } from \"./clients/factory\";\r\nimport type { WhatsAppConfig, WhatsAppMessage, WhatsAppWebhookEvent } from \"./types\";\r\nimport { MessageHandler, WebhookHandler } from \"./handlers\";\r\nimport { WhatsAppConnectorService } from \"./service\";\r\n\r\nexport class WhatsAppPlugin extends EventEmitter implements Plugin {\r\n    private client: IWhatsAppClient;\r\n    private messageHandler: MessageHandler;\r\n    private webhookHandler: WebhookHandler;\r\n\r\n    name: string;\r\n    description: string;\r\n\r\n    constructor(config: WhatsAppConfig) {\r\n        super();\r\n        this.name = \"WhatsApp Plugin\";\r\n        this.description = \"WhatsApp integration supporting both Cloud API and Baileys\";\r\n\r\n        this.client = ClientFactory.create(config);\r\n        this.messageHandler = new MessageHandler(this.client);\r\n        this.webhookHandler = new WebhookHandler(this.client);\r\n\r\n        // Forward client events\r\n        this.client.on('message', (msg) => this.emit('message', msg));\r\n        this.client.on('qr', (qr) => this.emit('qr', qr));\r\n        this.client.on('ready', () => this.emit('ready'));\r\n        this.client.on('connection', (status) => this.emit('connection', status));\r\n        this.client.on('error', (err) => this.emit('error', err));\r\n    }\r\n\r\n    async start(): Promise<void> {\r\n        await this.client.start();\r\n    }\r\n\r\n    async stop(): Promise<void> {\r\n        await this.client.stop();\r\n    }\r\n\r\n    async sendMessage(message: WhatsAppMessage): Promise<any> {\r\n        return this.messageHandler.send(message);\r\n    }\r\n\r\n    async handleWebhook(event: WhatsAppWebhookEvent): Promise<void> {\r\n        return this.webhookHandler.handle(event);\r\n    }\r\n\r\n    async verifyWebhook(token: string): Promise<boolean> {\r\n        if (!this.client.verifyWebhook) {\r\n            throw new Error('verifyWebhook is not supported by this client implementation');\r\n        }\r\n        return this.client.verifyWebhook(token);\r\n    }\r\n\r\n    getConnectionStatus() {\r\n        return this.client.getConnectionStatus();\r\n    }\r\n}\r\n\r\nexport * from \"./types\";\r\nexport { ClientFactory } from \"./clients/factory\";\r\nexport { WhatsAppConnectorService } from \"./service\";\r\n\r\nconst whatsappPlugin: Plugin = {\r\n  name: \"whatsapp\",\r\n  description: \"WhatsApp connector for ElizaOS — supports Baileys (QR code) and Cloud API\",\r\n  services: [WhatsAppConnectorService],\r\n};\r\n\r\nexport default whatsappPlugin;\r\n","import { EventEmitter } from 'events';\nimport type { IWhatsAppClient } from './interface';\nimport type { BaileysConfig, WhatsAppMessage, ConnectionStatus } from '../types';\nimport { BaileysAuthManager } from '../baileys/auth';\nimport { BaileysConnection } from '../baileys/connection';\nimport { QRCodeGenerator } from '../baileys/qr-code';\nimport { MessageAdapter } from '../baileys/message-adapter';\n\nexport class BaileysClient extends EventEmitter implements IWhatsAppClient {\n  private config: BaileysConfig;\n  private authManager: BaileysAuthManager;\n  private connection: BaileysConnection;\n  private qrGenerator: QRCodeGenerator;\n  private adapter: MessageAdapter;\n\n  constructor(config: BaileysConfig) {\n    super();\n    this.config = config;\n    this.authManager = new BaileysAuthManager(config.authDir);\n    this.connection = new BaileysConnection(this.authManager);\n    this.qrGenerator = new QRCodeGenerator();\n    this.adapter = new MessageAdapter();\n\n    this.setupEventForwarding();\n  }\n\n  private setupEventForwarding() {\n    // QR Code\n    this.connection.on('qr', async (qr: string) => {\n      try {\n        const qrData = await this.qrGenerator.generate(qr);\n\n        if (this.config.printQRInTerminal !== false) {\n          console.log('\\n=== Scan QR Code ===\\n');\n          console.log(qrData.terminal);\n        }\n\n        this.emit('qr', qrData);\n      } catch (err) {\n        console.error('QR code generation failed:', err);\n        this.emit('error', err);\n      }\n    });\n\n    // Connection status\n    this.connection.on('connection', (status: ConnectionStatus) => {\n      this.emit('connection', status);\n      if (status === 'open') {\n        this.emit('ready');\n      }\n    });\n\n    // Messages\n    this.connection.on('messages', (messages: any[]) => {\n      for (const msg of messages) {\n        if (!msg.key.fromMe && msg.message) {\n          const unified = this.adapter.toUnified(msg);\n          this.emit('message', unified);\n        }\n      }\n    });\n\n    // Error forwarding\n    this.connection.on('error', (err: Error) => {\n      this.emit('error', err);\n    });\n  }\n\n  async start(): Promise<void> {\n    await this.connection.connect();\n  }\n\n  async stop(): Promise<void> {\n    await this.connection.disconnect();\n  }\n\n  async sendMessage(message: WhatsAppMessage): Promise<any> {\n    const socket = this.connection.getSocket();\n    if (!socket) {\n      throw new Error('Not connected to WhatsApp');\n    }\n\n    const content = this.adapter.toBaileys(message);\n    return socket.sendMessage(message.to, content);\n  }\n\n  getConnectionStatus(): ConnectionStatus {\n    return this.connection.getStatus();\n  }\n}\n","import { useMultiFileAuthState } from '@whiskeysockets/baileys';\nimport type { AuthenticationState } from '@whiskeysockets/baileys';\n\nexport class BaileysAuthManager {\n  private authDir: string;\n  private state?: AuthenticationState;\n  private saveCreds?: () => Promise<void>;\n\n  constructor(authDir: string) {\n    this.authDir = authDir;\n  }\n\n  async initialize() {\n    const result = await useMultiFileAuthState(this.authDir);\n    this.state = result.state;\n    this.saveCreds = result.saveCreds;\n    return this.state;\n  }\n\n  async save() {\n    if (this.saveCreds) {\n      await this.saveCreds();\n    }\n  }\n\n  getState() {\n    return this.state;\n  }\n}\n","import makeWASocket, { DisconnectReason, WASocket } from '@whiskeysockets/baileys';\r\nimport { Boom } from '@hapi/boom';\r\nimport pino from 'pino';\r\nimport { EventEmitter } from 'events';\r\nimport type { BaileysAuthManager } from './auth';\r\nimport type { ConnectionStatus } from '../types';\r\n\r\nexport class BaileysConnection extends EventEmitter {\r\n  private socket?: WASocket;\r\n  private authManager: BaileysAuthManager;\r\n  private connectionStatus: ConnectionStatus = 'close';\r\n  private reconnecting = false;\r\n  private reconnectAttempts = 0;\r\n  private readonly MAX_RECONNECT_ATTEMPTS = 10;\r\n\r\n  constructor(authManager: BaileysAuthManager) {\r\n    super();\r\n    this.authManager = authManager;\r\n  }\r\n\r\n  async connect() {\r\n    const state = await this.authManager.initialize();\r\n\r\n    // Remove listeners from previous socket to prevent stale handlers\r\n    if (this.socket?.ev) {\r\n      this.socket.ev.removeAllListeners('connection.update');\r\n      this.socket.ev.removeAllListeners('creds.update');\r\n      this.socket.ev.removeAllListeners('messages.upsert');\r\n    }\r\n\r\n    this.socket = makeWASocket({\r\n      auth: state,\r\n      printQRInTerminal: false,\r\n      logger: pino({ level: 'silent' }),\r\n      browser: ['Chrome (Linux)', '', ''],\r\n    });\r\n\r\n    this.setupEventHandlers();\r\n    return this.socket;\r\n  }\r\n\r\n  private setupEventHandlers() {\r\n    if (!this.socket) return;\r\n\r\n    // QR Code & Connection\r\n    this.socket.ev.on('connection.update', async (update) => {\r\n      const { connection, qr, lastDisconnect } = update;\r\n\r\n      if (qr) {\r\n        this.emit('qr', qr);\r\n      }\r\n\r\n      if (connection) {\r\n        this.connectionStatus = connection;\r\n        this.emit('connection', connection);\r\n      }\r\n\r\n      if (connection === 'close') {\r\n        const statusCode = (lastDisconnect?.error as Boom)?.output?.statusCode;\r\n\r\n        // Handle specific error codes\r\n        if (statusCode === 405) {\r\n          console.error('WhatsApp rejected the connection (405). This usually means:');\r\n          console.error('  - Baileys version is outdated');\r\n          console.error('  - WhatsApp protocol has changed');\r\n          console.error('  - Browser info is rejected by WhatsApp');\r\n          this.emit('error', new Error('WhatsApp connection rejected (405). Try updating @whiskeysockets/baileys'));\r\n          return; // Don't reconnect on 405\r\n        }\r\n\r\n        // 515 = QR code timeout, this is expected\r\n        const isQRTimeout = statusCode === 515;\r\n        if (isQRTimeout) {\r\n          console.log('QR code timed out, generating new one...');\r\n        }\r\n\r\n        const shouldReconnect = statusCode !== DisconnectReason.loggedOut;\r\n\r\n        // Only emit error for unexpected errors (not QR timeout)\r\n        if (lastDisconnect?.error && !isQRTimeout) {\r\n          console.error('Connection error:', lastDisconnect.error.message || lastDisconnect.error);\r\n        }\r\n\r\n        if (shouldReconnect && statusCode !== 405) {\r\n          // Prevent concurrent reconnection attempts\r\n          if (this.reconnecting) {\r\n            return;\r\n          }\r\n\r\n          // Check if max attempts reached\r\n          if (this.reconnectAttempts >= this.MAX_RECONNECT_ATTEMPTS) {\r\n            console.error(`Max reconnection attempts (${this.MAX_RECONNECT_ATTEMPTS}) reached. Giving up.`);\r\n            this.emit('error', new Error('Max reconnection attempts reached'));\r\n            return;\r\n          }\r\n\r\n          this.reconnecting = true;\r\n          try {\r\n            this.reconnectAttempts++;\r\n\r\n            // Exponential backoff: 1s, 2s, 4s, 8s, etc., capped at 30s\r\n            const baseDelay = isQRTimeout ? 1000 : 3000;\r\n            const exponentialDelay = Math.min(baseDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);\r\n\r\n            console.log(`Reconnecting in ${exponentialDelay/1000} seconds... (attempt ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS})`);\r\n\r\n            await new Promise(resolve => setTimeout(resolve, exponentialDelay));\r\n            await this.connect();\r\n          } catch (err) {\r\n            console.error('Reconnection failed:', err);\r\n            this.emit('error', err);\r\n          } finally {\r\n            this.reconnecting = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Reset reconnect counter on successful connection\r\n      if (connection === 'open') {\r\n        this.reconnectAttempts = 0;\r\n      }\r\n    });\r\n\r\n    // Save credentials\r\n    this.socket.ev.on('creds.update', async () => {\r\n      await this.authManager.save();\r\n    });\r\n\r\n    // Messages\r\n    this.socket.ev.on('messages.upsert', ({ messages }) => {\r\n      this.emit('messages', messages);\r\n    });\r\n  }\r\n\r\n  getSocket() {\r\n    return this.socket;\r\n  }\r\n\r\n  getStatus() {\r\n    return this.connectionStatus;\r\n  }\r\n\r\n  async disconnect() {\r\n    if (this.socket) {\r\n      // Remove all event listeners from the Baileys event emitter\r\n      this.socket.ev.removeAllListeners('connection.update');\r\n      this.socket.ev.removeAllListeners('creds.update');\r\n      this.socket.ev.removeAllListeners('messages.upsert');\r\n\r\n      // Close the WebSocket connection (preserves session for next connection)\r\n      if (this.socket.ws) {\r\n        this.socket.ws.close();\r\n      }\r\n\r\n      this.socket = undefined;\r\n      this.connectionStatus = 'close';\r\n\r\n      // Emit connection event for consistency\r\n      this.emit('connection', 'close');\r\n    }\r\n  }\r\n}\r\n","import QRCode from 'qrcode';\nimport QRCodeTerminal from 'qrcode-terminal';\nimport type { QRCodeData } from '../types';\n\nexport class QRCodeGenerator {\n  async generate(qrString: string): Promise<QRCodeData> {\n    return {\n      terminal: await this.generateTerminal(qrString),\n      dataURL: await QRCode.toDataURL(qrString),\n      raw: qrString\n    };\n  }\n\n  private async generateTerminal(qr: string): Promise<string> {\n    return new Promise((resolve) => {\n      QRCodeTerminal.generate(qr, { small: true }, (output) => {\n        resolve(output);\n      });\n    });\n  }\n}\n","import type { proto } from '@whiskeysockets/baileys';\nimport type { UnifiedMessage, WhatsAppMessage } from '../types';\n\nexport class MessageAdapter {\n  // Convert Baileys message to unified format\n  toUnified(msg: proto.IWebMessageInfo): UnifiedMessage {\n    return {\n      id: msg.key?.id ?? '',\n      from: msg.key?.remoteJid ?? '',\n      timestamp: Number(msg.messageTimestamp ?? 0),\n      type: this.detectType(msg),\n      content: this.extractContent(msg)\n    };\n  }\n\n  // Convert unified message to Baileys format\n  toBaileys(msg: WhatsAppMessage) {\n    if (msg.type === 'text') {\n      return { text: msg.content as string };\n    }\n    // Add more types as needed\n    throw new Error(`Message type ${msg.type} not yet supported for Baileys`);\n  }\n\n  private detectType(msg: proto.IWebMessageInfo): 'text' | 'image' | 'audio' | 'video' | 'document' {\n    if (msg.message?.conversation) return 'text';\n    if (msg.message?.extendedTextMessage) return 'text';\n    if (msg.message?.imageMessage) return 'image';\n    if (msg.message?.audioMessage) return 'audio';\n    if (msg.message?.videoMessage) return 'video';\n    if (msg.message?.documentMessage) return 'document';\n    return 'text';\n  }\n\n  private extractContent(msg: proto.IWebMessageInfo): string {\n    return msg.message?.conversation ||\n           msg.message?.extendedTextMessage?.text ||\n           '';\n  }\n}\n","import axios, { type AxiosInstance } from \"axios\";\nimport { EventEmitter } from \"events\";\nimport type { IWhatsAppClient } from \"./interface\";\nimport type { CloudAPIConfig, WhatsAppMessage, ConnectionStatus } from \"../types\";\n\nexport class CloudAPIClient extends EventEmitter implements IWhatsAppClient {\n    private client: AxiosInstance;\n    private config: CloudAPIConfig;\n\n    constructor(config: CloudAPIConfig) {\n        super();\n        this.config = config;\n        // Default to v24.0 (current version). Supported range: v19.0 - v24.0\n        const apiVersion = config.apiVersion || 'v24.0';\n        this.client = axios.create({\n            baseURL: `https://graph.facebook.com/${apiVersion}`,\n            headers: {\n                Authorization: `Bearer ${config.accessToken}`,\n                \"Content-Type\": \"application/json\",\n            },\n        });\n    }\n\n    async start(): Promise<void> {\n        // Cloud API doesn't need initialization\n        // Emit ready immediately\n        this.emit('ready');\n    }\n\n    async stop(): Promise<void> {\n        // Cloud API doesn't need cleanup\n    }\n\n    async sendMessage(message: WhatsAppMessage): Promise<any> {\n        const endpoint = `/${this.config.phoneNumberId}/messages`;\n\n        const payload = {\n            messaging_product: \"whatsapp\",\n            recipient_type: \"individual\",\n            to: message.to,\n            type: message.type,\n            ...(message.type === \"text\"\n                ? { text: { body: message.content } }\n                : { template: message.content }),\n        };\n\n        return this.client.post(endpoint, payload);\n    }\n\n    async verifyWebhook(token: string): Promise<boolean> {\n        return token === this.config.webhookVerifyToken;\n    }\n\n    getConnectionStatus(): ConnectionStatus {\n        // Cloud API is always \"open\" once constructed\n        return 'open';\n    }\n}\n","import type { WhatsAppConfig } from '../types';\n\nexport function detectAuthMethod(config: any): 'baileys' | 'cloudapi' {\n  // Explicit method specified\n  if (config.authMethod) {\n    if (config.authMethod !== 'baileys' && config.authMethod !== 'cloudapi') {\n      throw new Error(\n        `Invalid authMethod: \"${config.authMethod}\". Must be either \"baileys\" or \"cloudapi\".`\n      );\n    }\n    return config.authMethod;\n  }\n\n  // Auto-detect from fields\n  if (config.authDir || config.sessionPath || config.authState) {\n    return 'baileys';\n  }\n\n  if (config.accessToken && config.phoneNumberId) {\n    return 'cloudapi';\n  }\n\n  throw new Error(\n    'Cannot detect auth method. Provide either:\\n' +\n    '  - authDir (for Baileys QR code)\\n' +\n    '  - accessToken + phoneNumberId (for Cloud API)'\n  );\n}\n","import type { WhatsAppConfig, BaileysConfig, CloudAPIConfig } from '../types';\nimport type { IWhatsAppClient } from './interface';\nimport { BaileysClient } from './baileys-client';\nimport { CloudAPIClient } from './cloud-api-client';\nimport { detectAuthMethod } from '../utils/config-detector';\n\nexport class ClientFactory {\n  static create(config: WhatsAppConfig): IWhatsAppClient {\n    const authMethod = detectAuthMethod(config);\n\n    if (authMethod === 'baileys') {\n      return new BaileysClient(config as BaileysConfig);\n    } else {\n      return new CloudAPIClient(config as CloudAPIConfig);\n    }\n  }\n}\n","import type { IWhatsAppClient } from \"../clients/interface\";\r\nimport type { WhatsAppMessage } from \"../types\";\r\n\r\nexport class MessageHandler {\r\n    constructor(private client: IWhatsAppClient) {}\r\n\r\n    async send(message: WhatsAppMessage): Promise<any> {\r\n        try {\r\n            const response = await this.client.sendMessage(message);\r\n            // Cloud API returns { data: ... }, Baileys returns the response directly\r\n            return response?.data ?? response;\r\n        } catch (error: unknown) {\r\n            if (error instanceof Error) {\r\n                throw new Error(\r\n                    `Failed to send WhatsApp message: ${error.message}`\r\n                );\r\n            }\r\n            throw new Error(\"Failed to send WhatsApp message\");\r\n        }\r\n    }\r\n}\r\n","import type { IWhatsAppClient } from \"../clients/interface\";\r\nimport type { WhatsAppWebhookEvent } from \"../types\";\r\n\r\nexport class WebhookHandler {\r\n    constructor(private client: IWhatsAppClient) {}\r\n\r\n    async handle(event: WhatsAppWebhookEvent): Promise<void> {\r\n        try {\r\n            // Process messages\r\n            if (event.entry?.[0]?.changes?.[0]?.value?.messages) {\r\n                const messages = event.entry[0].changes[0].value.messages;\r\n                for (const message of messages) {\r\n                    await this.handleMessage(message);\r\n                }\r\n            }\r\n\r\n            // Process status updates\r\n            if (event.entry?.[0]?.changes?.[0]?.value?.statuses) {\r\n                const statuses = event.entry[0].changes[0].value.statuses;\r\n                for (const status of statuses) {\r\n                    await this.handleStatus(status);\r\n                }\r\n            }\r\n        } catch (error: unknown) {\r\n            if (error instanceof Error) {\r\n                throw new Error(\r\n                    `Failed to send WhatsApp message: ${error.message}`\r\n                );\r\n            }\r\n            throw new Error(\"Failed to send WhatsApp message\");\r\n        }\r\n    }\r\n\r\n    private async handleMessage(message: any): Promise<void> {\r\n        // Implement message handling logic\r\n        // This could emit events or trigger callbacks based on your framework's needs\r\n        console.log(\"Received message:\", message);\r\n    }\r\n\r\n    private async handleStatus(status: any): Promise<void> {\r\n        // Implement status update handling logic\r\n        // This could emit events or trigger callbacks based on your framework's needs\r\n        console.log(\"Received status update:\", status);\r\n    }\r\n}\r\n","import {\n  type IAgentRuntime,\n  type Memory,\n  type Content,\n  type TargetInfo,\n  Service,\n  EventType,\n  ChannelType,\n  logger,\n  stringToUuid,\n} from \"@elizaos/core\";\nimport { WhatsAppPlugin } from \"./index\";\nimport type { WhatsAppConfig, UnifiedMessage } from \"./types\";\n\nconst SOURCE = \"whatsapp\";\n\n/** Read a setting from runtime (character settings) with fallback to process.env */\nfunction getSetting(runtime: IAgentRuntime, key: string): string | null {\n  const v = runtime.getSetting(key);\n  if (v !== null && v !== undefined) return String(v);\n  const e = process.env[key];\n  return e !== undefined ? e : null;\n}\n\nexport class WhatsAppConnectorService extends Service {\n  static serviceType = \"whatsapp_connector\";\n  capabilityDescription =\n    \"Connects the agent to WhatsApp using Baileys (QR code) or Cloud API\";\n\n  private plugin: WhatsAppPlugin | null = null;\n\n  static async start(\n    runtime: IAgentRuntime\n  ): Promise<WhatsAppConnectorService> {\n    const service = new WhatsAppConnectorService(runtime);\n    await service.initialize();\n    return service;\n  }\n\n  async stop(): Promise<void> {\n    if (this.plugin) {\n      await this.plugin.stop();\n      this.plugin = null;\n      logger.info(\"[WhatsApp] Disconnected\");\n    }\n  }\n\n  private resolveConfig(): WhatsAppConfig | null {\n    const runtime = this.runtime;\n\n    // Baileys (QR code) preferred when authDir is set\n    const authDir = getSetting(runtime, \"WHATSAPP_AUTH_DIR\");\n    if (authDir) {\n      return { authDir, printQRInTerminal: true };\n    }\n\n    // Cloud API\n    const accessToken = getSetting(runtime, \"WHATSAPP_ACCESS_TOKEN\");\n    const phoneNumberId = getSetting(runtime, \"WHATSAPP_PHONE_NUMBER_ID\");\n    if (accessToken && phoneNumberId) {\n      return {\n        accessToken,\n        phoneNumberId,\n        webhookVerifyToken: getSetting(runtime, \"WHATSAPP_WEBHOOK_VERIFY_TOKEN\") ?? undefined,\n        businessAccountId: getSetting(runtime, \"WHATSAPP_BUSINESS_ID\") ?? undefined,\n        apiVersion: getSetting(runtime, \"WHATSAPP_API_VERSION\") ?? undefined,\n      };\n    }\n\n    return null;\n  }\n\n  private async initialize(): Promise<void> {\n    const runtime = this.runtime;\n    const config = this.resolveConfig();\n    if (!config) {\n      logger.warn(\n        \"[WhatsApp] No configuration found (set WHATSAPP_AUTH_DIR for Baileys or \" +\n        \"WHATSAPP_ACCESS_TOKEN + WHATSAPP_PHONE_NUMBER_ID for Cloud API) — connector disabled\"\n      );\n      return;\n    }\n\n    this.plugin = new WhatsAppPlugin(config);\n\n    this.plugin.on(\"qr\", (qrData: { terminal?: string; dataURL?: string }) => {\n      logger.info(\"[WhatsApp] Scan the QR code below with your phone:\");\n      process.stdout.write(\"\\n\" + (qrData.terminal ?? String(qrData)) + \"\\n\\n\");\n    });\n\n    this.plugin.on(\"ready\", () => {\n      logger.info(\"[WhatsApp] Connected!\");\n    });\n\n    this.plugin.on(\"connection\", (status: string) => {\n      logger.info(`[WhatsApp] Connection status: ${status}`);\n    });\n\n    this.plugin.on(\"error\", (err: Error) => {\n      logger.error(\"[WhatsApp] Error:\", err.message);\n    });\n\n    this.plugin.on(\"message\", async (msg: UnifiedMessage) => {\n      await this.handleIncomingMessage(msg);\n    });\n\n    // Register send handler so the runtime can route replies back to WhatsApp\n    runtime.registerSendHandler(\n      SOURCE,\n      async (_rt: IAgentRuntime, target: TargetInfo, content: Content): Promise<void> => {\n        if (!this.plugin || !content.text) return;\n        const to = target.channelId ?? (target.entityId ? String(target.entityId) : null);\n        if (!to) return;\n        await this.plugin.sendMessage({\n          type: \"text\",\n          to,\n          content: content.text,\n        });\n      }\n    );\n\n    await this.plugin.start();\n    logger.info(\"[WhatsApp] Connector service started\");\n  }\n\n  private async handleIncomingMessage(msg: UnifiedMessage): Promise<void> {\n    const runtime = this.runtime;\n    if (!msg.content || msg.type !== \"text\") return;\n\n    // Derive consistent UUIDs from WhatsApp JIDs\n    const entityId = stringToUuid(`whatsapp-entity-${msg.from}`);\n    const roomId = stringToUuid(`whatsapp-room-${msg.from}-${runtime.agentId}`);\n    const worldId = stringToUuid(`whatsapp-world-${runtime.agentId}`);\n\n    // Ensure the WhatsApp world exists\n    await runtime.ensureWorldExists({\n      id: worldId,\n      agentId: runtime.agentId,\n      name: \"WhatsApp\",\n      metadata: { source: SOURCE },\n    });\n\n    // Ensure entity, room, and participant in one call\n    await runtime.ensureConnection({\n      entityId,\n      roomId,\n      worldId,\n      userName: msg.from,\n      name: msg.from,\n      source: SOURCE,\n      type: ChannelType.DM,\n      channelId: msg.from,\n    });\n\n    const memory: Memory = {\n      id: stringToUuid(`whatsapp-msg-${msg.id}`),\n      agentId: runtime.agentId,\n      entityId,\n      roomId,\n      content: {\n        text: msg.content,\n        source: SOURCE,\n        channelId: msg.from,\n      },\n      createdAt: msg.timestamp ? msg.timestamp * 1000 : Date.now(),\n      metadata: { type: \"message\", timestamp: Date.now(), scope: \"private\" },\n    };\n\n    await runtime.createMemory(memory, \"messages\");\n\n    await runtime.emitEvent(EventType.MESSAGE_RECEIVED, {\n      runtime,\n      message: memory,\n      source: SOURCE,\n      callback: async (response: Content): Promise<Memory[]> => {\n        if (response.text && this.plugin) {\n          await this.plugin.sendMessage({\n            type: \"text\",\n            to: msg.from,\n            content: response.text,\n          });\n        }\n        return [];\n      },\n    });\n  }\n}\n"],"mappings":";AAAA,SAAS,gBAAAA,qBAAoB;;;ACA7B,SAAS,gBAAAC,qBAAoB;;;ACA7B,SAAS,6BAA6B;AAG/B,IAAM,qBAAN,MAAyB;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAiB;AAC3B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,aAAa;AACjB,UAAM,SAAS,MAAM,sBAAsB,KAAK,OAAO;AACvD,SAAK,QAAQ,OAAO;AACpB,SAAK,YAAY,OAAO;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,OAAO;AACX,QAAI,KAAK,WAAW;AAClB,YAAM,KAAK,UAAU;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AACF;;;AC5BA,OAAO,gBAAgB,wBAAkC;AAEzD,OAAO,UAAU;AACjB,SAAS,oBAAoB;AAItB,IAAM,oBAAN,cAAgC,aAAa;AAAA,EAC1C;AAAA,EACA;AAAA,EACA,mBAAqC;AAAA,EACrC,eAAe;AAAA,EACf,oBAAoB;AAAA,EACX,yBAAyB;AAAA,EAE1C,YAAY,aAAiC;AAC3C,UAAM;AACN,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,MAAM,UAAU;AApBlB;AAqBI,UAAM,QAAQ,MAAM,KAAK,YAAY,WAAW;AAGhD,SAAI,UAAK,WAAL,mBAAa,IAAI;AACnB,WAAK,OAAO,GAAG,mBAAmB,mBAAmB;AACrD,WAAK,OAAO,GAAG,mBAAmB,cAAc;AAChD,WAAK,OAAO,GAAG,mBAAmB,iBAAiB;AAAA,IACrD;AAEA,SAAK,SAAS,aAAa;AAAA,MACzB,MAAM;AAAA,MACN,mBAAmB;AAAA,MACnB,QAAQ,KAAK,EAAE,OAAO,SAAS,CAAC;AAAA,MAChC,SAAS,CAAC,kBAAkB,IAAI,EAAE;AAAA,IACpC,CAAC;AAED,SAAK,mBAAmB;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,qBAAqB;AAC3B,QAAI,CAAC,KAAK,OAAQ;AAGlB,SAAK,OAAO,GAAG,GAAG,qBAAqB,OAAO,WAAW;AA7C7D;AA8CM,YAAM,EAAE,YAAY,IAAI,eAAe,IAAI;AAE3C,UAAI,IAAI;AACN,aAAK,KAAK,MAAM,EAAE;AAAA,MACpB;AAEA,UAAI,YAAY;AACd,aAAK,mBAAmB;AACxB,aAAK,KAAK,cAAc,UAAU;AAAA,MACpC;AAEA,UAAI,eAAe,SAAS;AAC1B,cAAM,cAAc,4DAAgB,UAAhB,mBAAgC,WAAhC,mBAAwC;AAG5D,YAAI,eAAe,KAAK;AACtB,kBAAQ,MAAM,6DAA6D;AAC3E,kBAAQ,MAAM,iCAAiC;AAC/C,kBAAQ,MAAM,mCAAmC;AACjD,kBAAQ,MAAM,0CAA0C;AACxD,eAAK,KAAK,SAAS,IAAI,MAAM,0EAA0E,CAAC;AACxG;AAAA,QACF;AAGA,cAAM,cAAc,eAAe;AACnC,YAAI,aAAa;AACf,kBAAQ,IAAI,0CAA0C;AAAA,QACxD;AAEA,cAAM,kBAAkB,eAAe,iBAAiB;AAGxD,aAAI,iDAAgB,UAAS,CAAC,aAAa;AACzC,kBAAQ,MAAM,qBAAqB,eAAe,MAAM,WAAW,eAAe,KAAK;AAAA,QACzF;AAEA,YAAI,mBAAmB,eAAe,KAAK;AAEzC,cAAI,KAAK,cAAc;AACrB;AAAA,UACF;AAGA,cAAI,KAAK,qBAAqB,KAAK,wBAAwB;AACzD,oBAAQ,MAAM,8BAA8B,KAAK,sBAAsB,uBAAuB;AAC9F,iBAAK,KAAK,SAAS,IAAI,MAAM,mCAAmC,CAAC;AACjE;AAAA,UACF;AAEA,eAAK,eAAe;AACpB,cAAI;AACF,iBAAK;AAGL,kBAAM,YAAY,cAAc,MAAO;AACvC,kBAAM,mBAAmB,KAAK,IAAI,YAAY,KAAK,IAAI,GAAG,KAAK,oBAAoB,CAAC,GAAG,GAAK;AAE5F,oBAAQ,IAAI,mBAAmB,mBAAiB,GAAI,wBAAwB,KAAK,iBAAiB,IAAI,KAAK,sBAAsB,GAAG;AAEpI,kBAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,gBAAgB,CAAC;AAClE,kBAAM,KAAK,QAAQ;AAAA,UACrB,SAAS,KAAK;AACZ,oBAAQ,MAAM,wBAAwB,GAAG;AACzC,iBAAK,KAAK,SAAS,GAAG;AAAA,UACxB,UAAE;AACA,iBAAK,eAAe;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AAGA,UAAI,eAAe,QAAQ;AACzB,aAAK,oBAAoB;AAAA,MAC3B;AAAA,IACF,CAAC;AAGD,SAAK,OAAO,GAAG,GAAG,gBAAgB,YAAY;AAC5C,YAAM,KAAK,YAAY,KAAK;AAAA,IAC9B,CAAC;AAGD,SAAK,OAAO,GAAG,GAAG,mBAAmB,CAAC,EAAE,SAAS,MAAM;AACrD,WAAK,KAAK,YAAY,QAAQ;AAAA,IAChC,CAAC;AAAA,EACH;AAAA,EAEA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,aAAa;AACjB,QAAI,KAAK,QAAQ;AAEf,WAAK,OAAO,GAAG,mBAAmB,mBAAmB;AACrD,WAAK,OAAO,GAAG,mBAAmB,cAAc;AAChD,WAAK,OAAO,GAAG,mBAAmB,iBAAiB;AAGnD,UAAI,KAAK,OAAO,IAAI;AAClB,aAAK,OAAO,GAAG,MAAM;AAAA,MACvB;AAEA,WAAK,SAAS;AACd,WAAK,mBAAmB;AAGxB,WAAK,KAAK,cAAc,OAAO;AAAA,IACjC;AAAA,EACF;AACF;;;ACjKA,OAAO,YAAY;AACnB,OAAO,oBAAoB;AAGpB,IAAM,kBAAN,MAAsB;AAAA,EAC3B,MAAM,SAAS,UAAuC;AACpD,WAAO;AAAA,MACL,UAAU,MAAM,KAAK,iBAAiB,QAAQ;AAAA,MAC9C,SAAS,MAAM,OAAO,UAAU,QAAQ;AAAA,MACxC,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,MAAc,iBAAiB,IAA6B;AAC1D,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,qBAAe,SAAS,IAAI,EAAE,OAAO,KAAK,GAAG,CAAC,WAAW;AACvD,gBAAQ,MAAM;AAAA,MAChB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;;;ACjBO,IAAM,iBAAN,MAAqB;AAAA;AAAA,EAE1B,UAAU,KAA4C;AALxD;AAMI,WAAO;AAAA,MACL,MAAI,SAAI,QAAJ,mBAAS,OAAM;AAAA,MACnB,QAAM,SAAI,QAAJ,mBAAS,cAAa;AAAA,MAC5B,WAAW,OAAO,IAAI,oBAAoB,CAAC;AAAA,MAC3C,MAAM,KAAK,WAAW,GAAG;AAAA,MACzB,SAAS,KAAK,eAAe,GAAG;AAAA,IAClC;AAAA,EACF;AAAA;AAAA,EAGA,UAAU,KAAsB;AAC9B,QAAI,IAAI,SAAS,QAAQ;AACvB,aAAO,EAAE,MAAM,IAAI,QAAkB;AAAA,IACvC;AAEA,UAAM,IAAI,MAAM,gBAAgB,IAAI,IAAI,gCAAgC;AAAA,EAC1E;AAAA,EAEQ,WAAW,KAA+E;AAxBpG;AAyBI,SAAI,SAAI,YAAJ,mBAAa,aAAc,QAAO;AACtC,SAAI,SAAI,YAAJ,mBAAa,oBAAqB,QAAO;AAC7C,SAAI,SAAI,YAAJ,mBAAa,aAAc,QAAO;AACtC,SAAI,SAAI,YAAJ,mBAAa,aAAc,QAAO;AACtC,SAAI,SAAI,YAAJ,mBAAa,aAAc,QAAO;AACtC,SAAI,SAAI,YAAJ,mBAAa,gBAAiB,QAAO;AACzC,WAAO;AAAA,EACT;AAAA,EAEQ,eAAe,KAAoC;AAlC7D;AAmCI,aAAO,SAAI,YAAJ,mBAAa,mBACb,eAAI,YAAJ,mBAAa,wBAAb,mBAAkC,SAClC;AAAA,EACT;AACF;;;AJ/BO,IAAM,gBAAN,cAA4BC,cAAwC;AAAA,EACjE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,QAAuB;AACjC,UAAM;AACN,SAAK,SAAS;AACd,SAAK,cAAc,IAAI,mBAAmB,OAAO,OAAO;AACxD,SAAK,aAAa,IAAI,kBAAkB,KAAK,WAAW;AACxD,SAAK,cAAc,IAAI,gBAAgB;AACvC,SAAK,UAAU,IAAI,eAAe;AAElC,SAAK,qBAAqB;AAAA,EAC5B;AAAA,EAEQ,uBAAuB;AAE7B,SAAK,WAAW,GAAG,MAAM,OAAO,OAAe;AAC7C,UAAI;AACF,cAAM,SAAS,MAAM,KAAK,YAAY,SAAS,EAAE;AAEjD,YAAI,KAAK,OAAO,sBAAsB,OAAO;AAC3C,kBAAQ,IAAI,0BAA0B;AACtC,kBAAQ,IAAI,OAAO,QAAQ;AAAA,QAC7B;AAEA,aAAK,KAAK,MAAM,MAAM;AAAA,MACxB,SAAS,KAAK;AACZ,gBAAQ,MAAM,8BAA8B,GAAG;AAC/C,aAAK,KAAK,SAAS,GAAG;AAAA,MACxB;AAAA,IACF,CAAC;AAGD,SAAK,WAAW,GAAG,cAAc,CAAC,WAA6B;AAC7D,WAAK,KAAK,cAAc,MAAM;AAC9B,UAAI,WAAW,QAAQ;AACrB,aAAK,KAAK,OAAO;AAAA,MACnB;AAAA,IACF,CAAC;AAGD,SAAK,WAAW,GAAG,YAAY,CAAC,aAAoB;AAClD,iBAAW,OAAO,UAAU;AAC1B,YAAI,CAAC,IAAI,IAAI,UAAU,IAAI,SAAS;AAClC,gBAAM,UAAU,KAAK,QAAQ,UAAU,GAAG;AAC1C,eAAK,KAAK,WAAW,OAAO;AAAA,QAC9B;AAAA,MACF;AAAA,IACF,CAAC;AAGD,SAAK,WAAW,GAAG,SAAS,CAAC,QAAe;AAC1C,WAAK,KAAK,SAAS,GAAG;AAAA,IACxB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,KAAK,WAAW,QAAQ;AAAA,EAChC;AAAA,EAEA,MAAM,OAAsB;AAC1B,UAAM,KAAK,WAAW,WAAW;AAAA,EACnC;AAAA,EAEA,MAAM,YAAY,SAAwC;AACxD,UAAM,SAAS,KAAK,WAAW,UAAU;AACzC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,UAAM,UAAU,KAAK,QAAQ,UAAU,OAAO;AAC9C,WAAO,OAAO,YAAY,QAAQ,IAAI,OAAO;AAAA,EAC/C;AAAA,EAEA,sBAAwC;AACtC,WAAO,KAAK,WAAW,UAAU;AAAA,EACnC;AACF;;;AKzFA,OAAO,WAAmC;AAC1C,SAAS,gBAAAC,qBAAoB;AAItB,IAAM,iBAAN,cAA6BA,cAAwC;AAAA,EAChE;AAAA,EACA;AAAA,EAER,YAAY,QAAwB;AAChC,UAAM;AACN,SAAK,SAAS;AAEd,UAAM,aAAa,OAAO,cAAc;AACxC,SAAK,SAAS,MAAM,OAAO;AAAA,MACvB,SAAS,8BAA8B,UAAU;AAAA,MACjD,SAAS;AAAA,QACL,eAAe,UAAU,OAAO,WAAW;AAAA,QAC3C,gBAAgB;AAAA,MACpB;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAuB;AAGzB,SAAK,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,MAAM,OAAsB;AAAA,EAE5B;AAAA,EAEA,MAAM,YAAY,SAAwC;AACtD,UAAM,WAAW,IAAI,KAAK,OAAO,aAAa;AAE9C,UAAM,UAAU;AAAA,MACZ,mBAAmB;AAAA,MACnB,gBAAgB;AAAA,MAChB,IAAI,QAAQ;AAAA,MACZ,MAAM,QAAQ;AAAA,MACd,GAAI,QAAQ,SAAS,SACf,EAAE,MAAM,EAAE,MAAM,QAAQ,QAAQ,EAAE,IAClC,EAAE,UAAU,QAAQ,QAAQ;AAAA,IACtC;AAEA,WAAO,KAAK,OAAO,KAAK,UAAU,OAAO;AAAA,EAC7C;AAAA,EAEA,MAAM,cAAc,OAAiC;AACjD,WAAO,UAAU,KAAK,OAAO;AAAA,EACjC;AAAA,EAEA,sBAAwC;AAEpC,WAAO;AAAA,EACX;AACJ;;;ACvDO,SAAS,iBAAiB,QAAqC;AAEpE,MAAI,OAAO,YAAY;AACrB,QAAI,OAAO,eAAe,aAAa,OAAO,eAAe,YAAY;AACvE,YAAM,IAAI;AAAA,QACR,wBAAwB,OAAO,UAAU;AAAA,MAC3C;AAAA,IACF;AACA,WAAO,OAAO;AAAA,EAChB;AAGA,MAAI,OAAO,WAAW,OAAO,eAAe,OAAO,WAAW;AAC5D,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,eAAe,OAAO,eAAe;AAC9C,WAAO;AAAA,EACT;AAEA,QAAM,IAAI;AAAA,IACR;AAAA,EAGF;AACF;;;ACrBO,IAAM,gBAAN,MAAoB;AAAA,EACzB,OAAO,OAAO,QAAyC;AACrD,UAAM,aAAa,iBAAiB,MAAM;AAE1C,QAAI,eAAe,WAAW;AAC5B,aAAO,IAAI,cAAc,MAAuB;AAAA,IAClD,OAAO;AACL,aAAO,IAAI,eAAe,MAAwB;AAAA,IACpD;AAAA,EACF;AACF;;;ACbO,IAAM,iBAAN,MAAqB;AAAA,EACxB,YAAoB,QAAyB;AAAzB;AAAA,EAA0B;AAAA,EAE9C,MAAM,KAAK,SAAwC;AAC/C,QAAI;AACA,YAAM,WAAW,MAAM,KAAK,OAAO,YAAY,OAAO;AAEtD,cAAO,qCAAU,SAAQ;AAAA,IAC7B,SAAS,OAAgB;AACrB,UAAI,iBAAiB,OAAO;AACxB,cAAM,IAAI;AAAA,UACN,oCAAoC,MAAM,OAAO;AAAA,QACrD;AAAA,MACJ;AACA,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACrD;AAAA,EACJ;AACJ;;;ACjBO,IAAM,iBAAN,MAAqB;AAAA,EACxB,YAAoB,QAAyB;AAAzB;AAAA,EAA0B;AAAA,EAE9C,MAAM,OAAO,OAA4C;AAN7D;AAOQ,QAAI;AAEA,WAAI,mCAAM,UAAN,mBAAc,OAAd,mBAAkB,YAAlB,mBAA4B,OAA5B,mBAAgC,UAAhC,mBAAuC,UAAU;AACjD,cAAM,WAAW,MAAM,MAAM,CAAC,EAAE,QAAQ,CAAC,EAAE,MAAM;AACjD,mBAAW,WAAW,UAAU;AAC5B,gBAAM,KAAK,cAAc,OAAO;AAAA,QACpC;AAAA,MACJ;AAGA,WAAI,mCAAM,UAAN,mBAAc,OAAd,mBAAkB,YAAlB,mBAA4B,OAA5B,mBAAgC,UAAhC,mBAAuC,UAAU;AACjD,cAAM,WAAW,MAAM,MAAM,CAAC,EAAE,QAAQ,CAAC,EAAE,MAAM;AACjD,mBAAW,UAAU,UAAU;AAC3B,gBAAM,KAAK,aAAa,MAAM;AAAA,QAClC;AAAA,MACJ;AAAA,IACJ,SAAS,OAAgB;AACrB,UAAI,iBAAiB,OAAO;AACxB,cAAM,IAAI;AAAA,UACN,oCAAoC,MAAM,OAAO;AAAA,QACrD;AAAA,MACJ;AACA,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACrD;AAAA,EACJ;AAAA,EAEA,MAAc,cAAc,SAA6B;AAGrD,YAAQ,IAAI,qBAAqB,OAAO;AAAA,EAC5C;AAAA,EAEA,MAAc,aAAa,QAA4B;AAGnD,YAAQ,IAAI,2BAA2B,MAAM;AAAA,EACjD;AACJ;;;AC5CA;AAAA,EAKE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIP,IAAM,SAAS;AAGf,SAAS,WAAW,SAAwB,KAA4B;AACtE,QAAM,IAAI,QAAQ,WAAW,GAAG;AAChC,MAAI,MAAM,QAAQ,MAAM,OAAW,QAAO,OAAO,CAAC;AAClD,QAAM,IAAI,QAAQ,IAAI,GAAG;AACzB,SAAO,MAAM,SAAY,IAAI;AAC/B;AAEO,IAAM,2BAAN,MAAM,kCAAiC,QAAQ;AAAA,EACpD,OAAO,cAAc;AAAA,EACrB,wBACE;AAAA,EAEM,SAAgC;AAAA,EAExC,aAAa,MACX,SACmC;AACnC,UAAM,UAAU,IAAI,0BAAyB,OAAO;AACpD,UAAM,QAAQ,WAAW;AACzB,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI,KAAK,QAAQ;AACf,YAAM,KAAK,OAAO,KAAK;AACvB,WAAK,SAAS;AACd,aAAO,KAAK,yBAAyB;AAAA,IACvC;AAAA,EACF;AAAA,EAEQ,gBAAuC;AAC7C,UAAM,UAAU,KAAK;AAGrB,UAAM,UAAU,WAAW,SAAS,mBAAmB;AACvD,QAAI,SAAS;AACX,aAAO,EAAE,SAAS,mBAAmB,KAAK;AAAA,IAC5C;AAGA,UAAM,cAAc,WAAW,SAAS,uBAAuB;AAC/D,UAAM,gBAAgB,WAAW,SAAS,0BAA0B;AACpE,QAAI,eAAe,eAAe;AAChC,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,oBAAoB,WAAW,SAAS,+BAA+B,KAAK;AAAA,QAC5E,mBAAmB,WAAW,SAAS,sBAAsB,KAAK;AAAA,QAClE,YAAY,WAAW,SAAS,sBAAsB,KAAK;AAAA,MAC7D;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,aAA4B;AACxC,UAAM,UAAU,KAAK;AACrB,UAAM,SAAS,KAAK,cAAc;AAClC,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,QACL;AAAA,MAEF;AACA;AAAA,IACF;AAEA,SAAK,SAAS,IAAI,eAAe,MAAM;AAEvC,SAAK,OAAO,GAAG,MAAM,CAAC,WAAoD;AACxE,aAAO,KAAK,oDAAoD;AAChE,cAAQ,OAAO,MAAM,QAAQ,OAAO,YAAY,OAAO,MAAM,KAAK,MAAM;AAAA,IAC1E,CAAC;AAED,SAAK,OAAO,GAAG,SAAS,MAAM;AAC5B,aAAO,KAAK,uBAAuB;AAAA,IACrC,CAAC;AAED,SAAK,OAAO,GAAG,cAAc,CAAC,WAAmB;AAC/C,aAAO,KAAK,iCAAiC,MAAM,EAAE;AAAA,IACvD,CAAC;AAED,SAAK,OAAO,GAAG,SAAS,CAAC,QAAe;AACtC,aAAO,MAAM,qBAAqB,IAAI,OAAO;AAAA,IAC/C,CAAC;AAED,SAAK,OAAO,GAAG,WAAW,OAAO,QAAwB;AACvD,YAAM,KAAK,sBAAsB,GAAG;AAAA,IACtC,CAAC;AAGD,YAAQ;AAAA,MACN;AAAA,MACA,OAAO,KAAoB,QAAoB,YAAoC;AACjF,YAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,KAAM;AACnC,cAAM,KAAK,OAAO,cAAc,OAAO,WAAW,OAAO,OAAO,QAAQ,IAAI;AAC5E,YAAI,CAAC,GAAI;AACT,cAAM,KAAK,OAAO,YAAY;AAAA,UAC5B,MAAM;AAAA,UACN;AAAA,UACA,SAAS,QAAQ;AAAA,QACnB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,KAAK,OAAO,MAAM;AACxB,WAAO,KAAK,sCAAsC;AAAA,EACpD;AAAA,EAEA,MAAc,sBAAsB,KAAoC;AACtE,UAAM,UAAU,KAAK;AACrB,QAAI,CAAC,IAAI,WAAW,IAAI,SAAS,OAAQ;AAGzC,UAAM,WAAW,aAAa,mBAAmB,IAAI,IAAI,EAAE;AAC3D,UAAM,SAAS,aAAa,iBAAiB,IAAI,IAAI,IAAI,QAAQ,OAAO,EAAE;AAC1E,UAAM,UAAU,aAAa,kBAAkB,QAAQ,OAAO,EAAE;AAGhE,UAAM,QAAQ,kBAAkB;AAAA,MAC9B,IAAI;AAAA,MACJ,SAAS,QAAQ;AAAA,MACjB,MAAM;AAAA,MACN,UAAU,EAAE,QAAQ,OAAO;AAAA,IAC7B,CAAC;AAGD,UAAM,QAAQ,iBAAiB;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU,IAAI;AAAA,MACd,MAAM,IAAI;AAAA,MACV,QAAQ;AAAA,MACR,MAAM,YAAY;AAAA,MAClB,WAAW,IAAI;AAAA,IACjB,CAAC;AAED,UAAM,SAAiB;AAAA,MACrB,IAAI,aAAa,gBAAgB,IAAI,EAAE,EAAE;AAAA,MACzC,SAAS,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,SAAS;AAAA,QACP,MAAM,IAAI;AAAA,QACV,QAAQ;AAAA,QACR,WAAW,IAAI;AAAA,MACjB;AAAA,MACA,WAAW,IAAI,YAAY,IAAI,YAAY,MAAO,KAAK,IAAI;AAAA,MAC3D,UAAU,EAAE,MAAM,WAAW,WAAW,KAAK,IAAI,GAAG,OAAO,UAAU;AAAA,IACvE;AAEA,UAAM,QAAQ,aAAa,QAAQ,UAAU;AAE7C,UAAM,QAAQ,UAAU,UAAU,kBAAkB;AAAA,MAClD;AAAA,MACA,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,UAAU,OAAO,aAAyC;AACxD,YAAI,SAAS,QAAQ,KAAK,QAAQ;AAChC,gBAAM,KAAK,OAAO,YAAY;AAAA,YAC5B,MAAM;AAAA,YACN,IAAI,IAAI;AAAA,YACR,SAAS,SAAS;AAAA,UACpB,CAAC;AAAA,QACH;AACA,eAAO,CAAC;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AXlLO,IAAM,iBAAN,cAA6BC,cAA+B;AAAA,EACvD;AAAA,EACA;AAAA,EACA;AAAA,EAER;AAAA,EACA;AAAA,EAEA,YAAY,QAAwB;AAChC,UAAM;AACN,SAAK,OAAO;AACZ,SAAK,cAAc;AAEnB,SAAK,SAAS,cAAc,OAAO,MAAM;AACzC,SAAK,iBAAiB,IAAI,eAAe,KAAK,MAAM;AACpD,SAAK,iBAAiB,IAAI,eAAe,KAAK,MAAM;AAGpD,SAAK,OAAO,GAAG,WAAW,CAAC,QAAQ,KAAK,KAAK,WAAW,GAAG,CAAC;AAC5D,SAAK,OAAO,GAAG,MAAM,CAAC,OAAO,KAAK,KAAK,MAAM,EAAE,CAAC;AAChD,SAAK,OAAO,GAAG,SAAS,MAAM,KAAK,KAAK,OAAO,CAAC;AAChD,SAAK,OAAO,GAAG,cAAc,CAAC,WAAW,KAAK,KAAK,cAAc,MAAM,CAAC;AACxE,SAAK,OAAO,GAAG,SAAS,CAAC,QAAQ,KAAK,KAAK,SAAS,GAAG,CAAC;AAAA,EAC5D;AAAA,EAEA,MAAM,QAAuB;AACzB,UAAM,KAAK,OAAO,MAAM;AAAA,EAC5B;AAAA,EAEA,MAAM,OAAsB;AACxB,UAAM,KAAK,OAAO,KAAK;AAAA,EAC3B;AAAA,EAEA,MAAM,YAAY,SAAwC;AACtD,WAAO,KAAK,eAAe,KAAK,OAAO;AAAA,EAC3C;AAAA,EAEA,MAAM,cAAc,OAA4C;AAC5D,WAAO,KAAK,eAAe,OAAO,KAAK;AAAA,EAC3C;AAAA,EAEA,MAAM,cAAc,OAAiC;AACjD,QAAI,CAAC,KAAK,OAAO,eAAe;AAC5B,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAClF;AACA,WAAO,KAAK,OAAO,cAAc,KAAK;AAAA,EAC1C;AAAA,EAEA,sBAAsB;AAClB,WAAO,KAAK,OAAO,oBAAoB;AAAA,EAC3C;AACJ;AAMA,IAAM,iBAAyB;AAAA,EAC7B,MAAM;AAAA,EACN,aAAa;AAAA,EACb,UAAU,CAAC,wBAAwB;AACrC;AAEA,IAAO,gBAAQ;","names":["EventEmitter","EventEmitter","EventEmitter","EventEmitter","EventEmitter"]}