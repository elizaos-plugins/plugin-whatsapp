{"version":3,"sources":["../src/index.ts","../src/clients/baileys-client.ts","../src/baileys/auth.ts","../src/baileys/connection.ts","../src/baileys/qr-code.ts","../src/baileys/message-adapter.ts","../src/clients/cloud-api-client.ts","../src/utils/config-detector.ts","../src/clients/factory.ts","../src/handlers/message.handler.ts","../src/handlers/webhook.handler.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport type { Plugin } from \"@elizaos/core\";\nimport type { IWhatsAppClient } from \"./clients/interface\";\nimport { ClientFactory } from \"./clients/factory\";\nimport type { WhatsAppConfig, WhatsAppMessage, WhatsAppWebhookEvent } from \"./types\";\nimport { MessageHandler, WebhookHandler } from \"./handlers\";\n\nexport class WhatsAppPlugin extends EventEmitter implements Plugin {\n    private client: IWhatsAppClient;\n    private messageHandler: MessageHandler;\n    private webhookHandler: WebhookHandler;\n\n    name: string;\n    description: string;\n\n    constructor(config: WhatsAppConfig) {\n        super();\n        this.name = \"WhatsApp Plugin\";\n        this.description = \"WhatsApp integration supporting both Cloud API and Baileys\";\n\n        this.client = ClientFactory.create(config);\n        this.messageHandler = new MessageHandler(this.client);\n        this.webhookHandler = new WebhookHandler(this.client);\n\n        // Forward client events\n        this.client.on('message', (msg) => this.emit('message', msg));\n        this.client.on('qr', (qr) => this.emit('qr', qr));\n        this.client.on('ready', () => this.emit('ready'));\n        this.client.on('connection', (status) => this.emit('connection', status));\n        this.client.on('error', (err) => this.emit('error', err));\n    }\n\n    async start(): Promise<void> {\n        await this.client.start();\n    }\n\n    async stop(): Promise<void> {\n        await this.client.stop();\n    }\n\n    async sendMessage(message: WhatsAppMessage): Promise<any> {\n        return this.messageHandler.send(message);\n    }\n\n    async handleWebhook(event: WhatsAppWebhookEvent): Promise<void> {\n        return this.webhookHandler.handle(event);\n    }\n\n    async verifyWebhook(token: string): Promise<boolean> {\n        if (!this.client.verifyWebhook) {\n            throw new Error('verifyWebhook is not supported by this client implementation');\n        }\n        return this.client.verifyWebhook(token);\n    }\n\n    getConnectionStatus() {\n        return this.client.getConnectionStatus();\n    }\n}\n\nexport * from \"./types\";\nexport { ClientFactory } from \"./clients/factory\";\n","import { EventEmitter } from 'events';\nimport type { IWhatsAppClient } from './interface';\nimport type { BaileysConfig, WhatsAppMessage, ConnectionStatus } from '../types';\nimport { BaileysAuthManager } from '../baileys/auth';\nimport { BaileysConnection } from '../baileys/connection';\nimport { QRCodeGenerator } from '../baileys/qr-code';\nimport { MessageAdapter } from '../baileys/message-adapter';\n\nexport class BaileysClient extends EventEmitter implements IWhatsAppClient {\n  private config: BaileysConfig;\n  private authManager: BaileysAuthManager;\n  private connection: BaileysConnection;\n  private qrGenerator: QRCodeGenerator;\n  private adapter: MessageAdapter;\n\n  constructor(config: BaileysConfig) {\n    super();\n    this.config = config;\n    this.authManager = new BaileysAuthManager(config.authDir);\n    this.connection = new BaileysConnection(this.authManager);\n    this.qrGenerator = new QRCodeGenerator();\n    this.adapter = new MessageAdapter();\n\n    this.setupEventForwarding();\n  }\n\n  private setupEventForwarding() {\n    // QR Code\n    this.connection.on('qr', async (qr: string) => {\n      try {\n        const qrData = await this.qrGenerator.generate(qr);\n\n        if (this.config.printQRInTerminal !== false) {\n          console.log('\\n=== Scan QR Code ===\\n');\n          console.log(qrData.terminal);\n        }\n\n        this.emit('qr', qrData);\n      } catch (err) {\n        console.error('QR code generation failed:', err);\n        this.emit('error', err);\n      }\n    });\n\n    // Connection status\n    this.connection.on('connection', (status: ConnectionStatus) => {\n      this.emit('connection', status);\n      if (status === 'open') {\n        this.emit('ready');\n      }\n    });\n\n    // Messages\n    this.connection.on('messages', (messages: any[]) => {\n      for (const msg of messages) {\n        if (!msg.key.fromMe && msg.message) {\n          const unified = this.adapter.toUnified(msg);\n          this.emit('message', unified);\n        }\n      }\n    });\n\n    // Error forwarding\n    this.connection.on('error', (err: Error) => {\n      this.emit('error', err);\n    });\n  }\n\n  async start(): Promise<void> {\n    await this.connection.connect();\n  }\n\n  async stop(): Promise<void> {\n    await this.connection.disconnect();\n  }\n\n  async sendMessage(message: WhatsAppMessage): Promise<any> {\n    const socket = this.connection.getSocket();\n    if (!socket) {\n      throw new Error('Not connected to WhatsApp');\n    }\n\n    const content = this.adapter.toBaileys(message);\n    return socket.sendMessage(message.to, content);\n  }\n\n  getConnectionStatus(): ConnectionStatus {\n    return this.connection.getStatus();\n  }\n}\n","import { useMultiFileAuthState } from '@whiskeysockets/baileys';\nimport type { AuthenticationState } from '@whiskeysockets/baileys';\n\nexport class BaileysAuthManager {\n  private authDir: string;\n  private state?: AuthenticationState;\n  private saveCreds?: () => Promise<void>;\n\n  constructor(authDir: string) {\n    this.authDir = authDir;\n  }\n\n  async initialize() {\n    const result = await useMultiFileAuthState(this.authDir);\n    this.state = result.state;\n    this.saveCreds = result.saveCreds;\n    return this.state;\n  }\n\n  async save() {\n    if (this.saveCreds) {\n      await this.saveCreds();\n    }\n  }\n\n  getState() {\n    return this.state;\n  }\n}\n","import makeWASocket, { DisconnectReason, WASocket } from '@whiskeysockets/baileys';\nimport { Boom } from '@hapi/boom';\nimport pino from 'pino';\nimport { EventEmitter } from 'events';\nimport type { BaileysAuthManager } from './auth';\nimport type { ConnectionStatus } from '../types';\n\nexport class BaileysConnection extends EventEmitter {\n  private socket?: WASocket;\n  private authManager: BaileysAuthManager;\n  private connectionStatus: ConnectionStatus = 'close';\n  private reconnecting = false;\n  private reconnectAttempts = 0;\n  private readonly MAX_RECONNECT_ATTEMPTS = 10;\n\n  constructor(authManager: BaileysAuthManager) {\n    super();\n    this.authManager = authManager;\n  }\n\n  async connect() {\n    const state = await this.authManager.initialize();\n\n    this.socket = makeWASocket({\n      auth: state,\n      printQRInTerminal: false,\n      logger: pino({ level: 'silent' }),\n      browser: ['Chrome (Linux)', '', ''],\n    });\n\n    this.setupEventHandlers();\n    return this.socket;\n  }\n\n  private setupEventHandlers() {\n    if (!this.socket) return;\n\n    // QR Code & Connection\n    this.socket.ev.on('connection.update', async (update) => {\n      const { connection, qr, lastDisconnect } = update;\n\n      if (qr) {\n        this.emit('qr', qr);\n      }\n\n      if (connection) {\n        this.connectionStatus = connection;\n        this.emit('connection', connection);\n      }\n\n      if (connection === 'close') {\n        const statusCode = (lastDisconnect?.error as Boom)?.output?.statusCode;\n\n        // Handle specific error codes\n        if (statusCode === 405) {\n          console.error('WhatsApp rejected the connection (405). This usually means:');\n          console.error('  - Baileys version is outdated');\n          console.error('  - WhatsApp protocol has changed');\n          console.error('  - Browser info is rejected by WhatsApp');\n          this.emit('error', new Error('WhatsApp connection rejected (405). Try updating @whiskeysockets/baileys'));\n          return; // Don't reconnect on 405\n        }\n\n        // 515 = QR code timeout, this is expected\n        const isQRTimeout = statusCode === 515;\n        if (isQRTimeout) {\n          console.log('QR code timed out, generating new one...');\n        }\n\n        const shouldReconnect = statusCode !== DisconnectReason.loggedOut;\n\n        // Only emit error for unexpected errors (not QR timeout)\n        if (lastDisconnect?.error && !isQRTimeout) {\n          console.error('Connection error:', lastDisconnect.error.message || lastDisconnect.error);\n        }\n\n        if (shouldReconnect && statusCode !== 405) {\n          // Prevent concurrent reconnection attempts\n          if (this.reconnecting) {\n            return;\n          }\n\n          // Check if max attempts reached\n          if (this.reconnectAttempts >= this.MAX_RECONNECT_ATTEMPTS) {\n            console.error(`Max reconnection attempts (${this.MAX_RECONNECT_ATTEMPTS}) reached. Giving up.`);\n            this.emit('error', new Error('Max reconnection attempts reached'));\n            return;\n          }\n\n          this.reconnecting = true;\n          try {\n            this.reconnectAttempts++;\n\n            // Exponential backoff: 1s, 2s, 4s, 8s, etc., capped at 30s\n            const baseDelay = isQRTimeout ? 1000 : 3000;\n            const exponentialDelay = Math.min(baseDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);\n\n            console.log(`Reconnecting in ${exponentialDelay/1000} seconds... (attempt ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS})`);\n\n            await new Promise(resolve => setTimeout(resolve, exponentialDelay));\n            await this.connect();\n          } catch (err) {\n            console.error('Reconnection failed:', err);\n            this.emit('error', err);\n          } finally {\n            this.reconnecting = false;\n          }\n        }\n      }\n\n      // Reset reconnect counter on successful connection\n      if (connection === 'open') {\n        this.reconnectAttempts = 0;\n      }\n    });\n\n    // Save credentials\n    this.socket.ev.on('creds.update', async () => {\n      await this.authManager.save();\n    });\n\n    // Messages\n    this.socket.ev.on('messages.upsert', ({ messages }) => {\n      this.emit('messages', messages);\n    });\n  }\n\n  getSocket() {\n    return this.socket;\n  }\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n\n  async disconnect() {\n    if (this.socket) {\n      // Remove all event listeners from the Baileys event emitter\n      this.socket.ev.removeAllListeners();\n\n      // Close the WebSocket connection (preserves session for next connection)\n      if (this.socket.ws) {\n        this.socket.ws.close();\n      }\n\n      this.socket = undefined;\n      this.connectionStatus = 'close';\n\n      // Emit connection event for consistency\n      this.emit('connection', 'close');\n    }\n  }\n}\n","import QRCode from 'qrcode';\nimport QRCodeTerminal from 'qrcode-terminal';\nimport type { QRCodeData } from '../types';\n\nexport class QRCodeGenerator {\n  async generate(qrString: string): Promise<QRCodeData> {\n    return {\n      terminal: await this.generateTerminal(qrString),\n      dataURL: await QRCode.toDataURL(qrString),\n      raw: qrString\n    };\n  }\n\n  private async generateTerminal(qr: string): Promise<string> {\n    return new Promise((resolve) => {\n      QRCodeTerminal.generate(qr, { small: true }, (output) => {\n        resolve(output);\n      });\n    });\n  }\n}\n","import type { proto } from '@whiskeysockets/baileys';\nimport type { UnifiedMessage, WhatsAppMessage } from '../types';\n\nexport class MessageAdapter {\n  // Convert Baileys message to unified format\n  toUnified(msg: proto.IWebMessageInfo): UnifiedMessage {\n    return {\n      id: msg.key?.id ?? '',\n      from: msg.key?.remoteJid ?? '',\n      timestamp: Number(msg.messageTimestamp ?? 0),\n      type: this.detectType(msg),\n      content: this.extractContent(msg)\n    };\n  }\n\n  // Convert unified message to Baileys format\n  toBaileys(msg: WhatsAppMessage) {\n    if (msg.type === 'text') {\n      return { text: msg.content as string };\n    }\n    // Add more types as needed\n    throw new Error(`Message type ${msg.type} not yet supported for Baileys`);\n  }\n\n  private detectType(msg: proto.IWebMessageInfo): 'text' | 'image' | 'audio' | 'video' | 'document' {\n    if (msg.message?.conversation) return 'text';\n    if (msg.message?.extendedTextMessage) return 'text';\n    if (msg.message?.imageMessage) return 'image';\n    if (msg.message?.audioMessage) return 'audio';\n    if (msg.message?.videoMessage) return 'video';\n    if (msg.message?.documentMessage) return 'document';\n    return 'text';\n  }\n\n  private extractContent(msg: proto.IWebMessageInfo): string {\n    return msg.message?.conversation ||\n           msg.message?.extendedTextMessage?.text ||\n           '';\n  }\n}\n","import axios, { type AxiosInstance } from \"axios\";\nimport { EventEmitter } from \"events\";\nimport type { IWhatsAppClient } from \"./interface\";\nimport type { CloudAPIConfig, WhatsAppMessage, ConnectionStatus } from \"../types\";\n\nexport class CloudAPIClient extends EventEmitter implements IWhatsAppClient {\n    private client: AxiosInstance;\n    private config: CloudAPIConfig;\n\n    constructor(config: CloudAPIConfig) {\n        super();\n        this.config = config;\n        // Default to v24.0 (current version). Supported range: v19.0 - v24.0\n        const apiVersion = config.apiVersion || 'v24.0';\n        this.client = axios.create({\n            baseURL: `https://graph.facebook.com/${apiVersion}`,\n            headers: {\n                Authorization: `Bearer ${config.accessToken}`,\n                \"Content-Type\": \"application/json\",\n            },\n        });\n    }\n\n    async start(): Promise<void> {\n        // Cloud API doesn't need initialization\n        // Emit ready immediately\n        this.emit('ready');\n    }\n\n    async stop(): Promise<void> {\n        // Cloud API doesn't need cleanup\n    }\n\n    async sendMessage(message: WhatsAppMessage): Promise<any> {\n        const endpoint = `/${this.config.phoneNumberId}/messages`;\n\n        const payload = {\n            messaging_product: \"whatsapp\",\n            recipient_type: \"individual\",\n            to: message.to,\n            type: message.type,\n            ...(message.type === \"text\"\n                ? { text: { body: message.content } }\n                : { template: message.content }),\n        };\n\n        return this.client.post(endpoint, payload);\n    }\n\n    async verifyWebhook(token: string): Promise<boolean> {\n        return token === this.config.webhookVerifyToken;\n    }\n\n    getConnectionStatus(): ConnectionStatus {\n        // Cloud API is always \"open\" once constructed\n        return 'open';\n    }\n}\n","import type { WhatsAppConfig } from '../types';\n\nexport function detectAuthMethod(config: any): 'baileys' | 'cloudapi' {\n  // Explicit method specified\n  if (config.authMethod) {\n    if (config.authMethod !== 'baileys' && config.authMethod !== 'cloudapi') {\n      throw new Error(\n        `Invalid authMethod: \"${config.authMethod}\". Must be either \"baileys\" or \"cloudapi\".`\n      );\n    }\n    return config.authMethod;\n  }\n\n  // Auto-detect from fields\n  if (config.authDir || config.sessionPath || config.authState) {\n    return 'baileys';\n  }\n\n  if (config.accessToken && config.phoneNumberId) {\n    return 'cloudapi';\n  }\n\n  throw new Error(\n    'Cannot detect auth method. Provide either:\\n' +\n    '  - authDir (for Baileys QR code)\\n' +\n    '  - accessToken + phoneNumberId (for Cloud API)'\n  );\n}\n","import type { WhatsAppConfig, BaileysConfig, CloudAPIConfig } from '../types';\nimport type { IWhatsAppClient } from './interface';\nimport { BaileysClient } from './baileys-client';\nimport { CloudAPIClient } from './cloud-api-client';\nimport { detectAuthMethod } from '../utils/config-detector';\n\nexport class ClientFactory {\n  static create(config: WhatsAppConfig): IWhatsAppClient {\n    const authMethod = detectAuthMethod(config);\n\n    if (authMethod === 'baileys') {\n      return new BaileysClient(config as BaileysConfig);\n    } else {\n      return new CloudAPIClient(config as CloudAPIConfig);\n    }\n  }\n}\n","import type { IWhatsAppClient } from \"../clients/interface\";\nimport type { WhatsAppMessage } from \"../types\";\n\nexport class MessageHandler {\n    constructor(private client: IWhatsAppClient) {}\n\n    async send(message: WhatsAppMessage): Promise<any> {\n        try {\n            const response = await this.client.sendMessage(message);\n            // Cloud API returns { data: ... }, Baileys returns the response directly\n            return response?.data ?? response;\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                throw new Error(\n                    `Failed to send WhatsApp message: ${error.message}`\n                );\n            }\n            throw new Error(\"Failed to send WhatsApp message\");\n        }\n    }\n}\n","import type { IWhatsAppClient } from \"../clients/interface\";\nimport type { WhatsAppWebhookEvent } from \"../types\";\n\nexport class WebhookHandler {\n    constructor(private client: IWhatsAppClient) {}\n\n    async handle(event: WhatsAppWebhookEvent): Promise<void> {\n        try {\n            // Process messages\n            if (event.entry?.[0]?.changes?.[0]?.value?.messages) {\n                const messages = event.entry[0].changes[0].value.messages;\n                for (const message of messages) {\n                    await this.handleMessage(message);\n                }\n            }\n\n            // Process status updates\n            if (event.entry?.[0]?.changes?.[0]?.value?.statuses) {\n                const statuses = event.entry[0].changes[0].value.statuses;\n                for (const status of statuses) {\n                    await this.handleStatus(status);\n                }\n            }\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                throw new Error(\n                    `Failed to send WhatsApp message: ${error.message}`\n                );\n            }\n            throw new Error(\"Failed to send WhatsApp message\");\n        }\n    }\n\n    private async handleMessage(message: any): Promise<void> {\n        // Implement message handling logic\n        // This could emit events or trigger callbacks based on your framework's needs\n        console.log(\"Received message:\", message);\n    }\n\n    private async handleStatus(status: any): Promise<void> {\n        // Implement status update handling logic\n        // This could emit events or trigger callbacks based on your framework's needs\n        console.log(\"Received status update:\", status);\n    }\n}\n"],"mappings":"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","names":["EventEmitter","EventEmitter","EventEmitter","EventEmitter","EventEmitter"]}